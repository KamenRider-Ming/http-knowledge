# 1. 介绍

在分布式系统中，通常都会缓存响应数据来提升性能。该文档定义了 `HTTP / 1.1` 中缓存和重用相关响应数据的各个方面。

HTTP 缓存是一个存储了响应数据的本地仓库，该仓库同时也提供了对数据进行存储、检索（读取）、删除等操作。当我们缓存了可被缓存的响应数据时，可以减少将来相同请求的响应时间和网络带宽消耗。任何客户端、服务器都可以拥有自己的缓存，但对于扮演一个 tunnel 角色的服务器来说，不能使用缓存。

共享缓存是一个可以被多个用户使用的 Cache。通常会被部署在访问链路中的某一个节点，充当中介的身份。相反的，私有缓存的响应数据只能被单个用户使用，通常它会实现在浏览器中即一个访问发出的起点。

`HTTP / 1.1` 中使用缓存目的是通过重用可以满足当前请求的历史响应数据来提高性能。如果可以在没有“验证”的情况下重用响应，则认为缓存的数据是“新鲜的“（ 相关定义在 4.2 节），所以如果一直使用“新鲜的”缓存数据，可以有效降低延时和网络开销，当缓存的响应不再“新鲜”时，如果通过验证（ 相关定义在 4.3 节）发现它仍然可以重用或者此时后端服务器已经不可用（ 相关定义在 4.2.4 节），则依旧认为缓存数据还是“新鲜的”。

## 1.1 一致性和错误处理

关于错误处理的一致性标准和注意事项被定义在 RFC7230 的 2.5 节。

## 1.2 语法表示法

### 1.2.1 Delta Seconds 规则

delta-seconds 规则指定一个非负整数的时间，其单位为秒。
```
    delta-seconds  = 1*DIGIT
```
解析 delta-seconds 并将其转为二进制形式的接收者应该限定其最大值为一个不少于31位（2^31）的非负整数。如果缓存接收了一个超出最大值的 delta-seconds，或后续计算溢出时，缓存必须将这个值视为 2147483648 (2^31) 或者它能表示的最大正整数。

注意：值 2147483648 在这里是出于历史原因，有效地代表了无限(超过68年)。如果发生溢出，可以实现一个基于字符串的计算方案，总的来说，不管发生什么，该值都不能为负数。

# 2 缓存操作概述

正确的缓存操作保留了 HTTP 传输的语义（[RFC7231]），同时消除了已经保存在缓存中的信息。虽然缓存是一个完全可选的 HTTP 特性，在没有必要要求或本地配置取消它的情况下重用是一个默认行为，所以可以认为重用被缓存的响应是众望所归的。因此，HTTP 缓存的着重点在于避免缓存不会被重用和不应该被重用的响应数据，而不是缓存所有的响应数据并且不断重用它。

每个缓存实体由一个缓存键和一个或多个使用相同键的先前请求的 HTTP 响应组成。最常见的缓存实体形式是成功请求的结果：即GET请求的200响应，它包含了请求资源的一个标识（RFC7231，4.3.1节）。当然它也可能缓存 302 重定向的响应数据、404网页丢失的响应数据、不完整返回数据（code: 206）以及对于非 GET 请求而言，如果方法定义允许被缓存并且定义了缓存键，那么它也可以被缓存。

缓存主键由请求方法和目标URI组成。但是，由于目前常用的 HTTP 缓存通常仅支持对 GET 的响应缓存，因此许多缓存简单地拒绝掉其他方法，仅使用URI作为缓存主键。

如果一个请求目标需要进行内容协商，它的缓存条目可能会包含多个响应，每个响应通过原始请求的请求头作为一个辅助键来区分（4.1节）。

# 3 在缓存中存储响应

遵循如下条件时，缓存会存储该请求的响应：

1. 请求方法能被缓存识别且允许被缓存。
2. 响应状态码能被缓存识别。
3. “no-store” 缓存指令（查看 5.2 节）没有出现在请求或响应头字段中。
4. 使用的是共享缓存并且“private” 响应指令（查看5.2.2.6节）没有出现在响应字段。
5. 使用的是共享缓存，默认情况下 Authorization 请求头字段不出现在请求头中才可以被缓存，但是允许服务器响应数据时通过相关字段告知可被缓存（查看3.2节）。
6. 响应数据时携带如下任一字段时会被缓存：
    - 包含 Expires 头字段（查看5.3节）。
    - 包含 max-age 响应指令（查看5.2.2.8节）。
    - 包含 s-maxage 响应指令（查看5.2.2.9节）同时是共享缓存。
    - 包含 Cache-Control 缓存控制（查看5.2.3节）。
    - 被定义为可缓存的状态码（查看4.2.2节）。
    - 包含 public 响应指令（查看5.2.2.5节）。

注意，上面列出的任何条件都可以通过 Cache-Control 来配置，具体查看5.2.3节。

在上述描述所提到的内容中，如果缓存实现了针对某个请求方法或响应状态码的相关行为，那么缓存就能识别它。

注意，一般情况下，缓存不会存储一个既没有缓存校验器又没有明确过期时间的响应数据，因为这样的响应存储下来通常是没有用的。不过，缓存没有对此作出限制。

## 3.1 存储不完整的响应

如果由消息帧组成的所有字节在连接被关闭前都被接收，则响应消息被视为完整的。如果请求方法是 GET ，响应状态码是 200，并且整个响应头部分已经被接收，缓存**可以**存储一个不完整的响应消息体，在缓存条目中被记录为不完整。同样的，206 响应也可以这样子被处理。然而，当缓存不支持 Range 和 Content-Range 头字段或者缓存无法识别头字段中使用的值时，它**不能**存储不完整或部分内容的响应数据。

缓存可以通过发起范围请求并将通过存储条目组合来完成一个不完整的响应的存储，如3.3节定义。除非响应已经是完整的，或请求所指定的范围全都在不完整响应中，否则缓存**不能**使用一个不完整的响应来应答请求。缓存**必须**在使用 206 状态码情况下才能够使用不完整响应返回给客户端。

## 3.2 存储对已认证请求的响应

共享缓存**不能**使用带 Authorization 头字段(4.2节 [RFC7235])请求的响应来满足后续请求，除非
在响应中明确指定可以被缓存。

在这个规范中，下列 Cache-Control （5.2.2 节）响应指令有这样的效果：must-revalidate，public，和 s-maxage。

注意，包含 “must-revalidate” 或 “s-maxage” 响应指令的缓存响应不允许被共享缓存处理。另外带有 “max-age=0, must-revalidate” 或 “s-maxage=0” 的响应不能在未经源服务器校验通过的情况下被用于满足后续请求。

## 3.3 合并部分内容

如果连接过早关闭或者如果请求使用了一个或多个 Range （[RFC7233]），响应可能只转移一部分表示。在几次这样的转移后，缓存可能已经接收到一些相同表示的范围。缓存可以将这些范围组成成一个存储响应，然后使用哪个响应来满足后续请求，如果他们都共享相同的强校验器并且缓存符合RFC7233中4.3节的客户端要求。

当将一个或多个已存储的响应组成新响应时，缓存必须：

1. 删除响应中的任何 1xx 的警告头字段（5.5节）。
2. 保留响应中的任何 2xx 的警告头字段。
3. 除了 Content-Range 外，新的响应中提供的头字段应该已存储响应中对应头字段。

# 4 从缓存构建响应

遵循如下条件时，缓存会使用已缓存的响应：

1. 有效请求的URI（RFC7230，5.5节）和已存储响应的URI匹配。
2. 请求方法允许它使用缓存。
3. 匹配了已存储响应（如果有的话）指定的选择头字段（4.1节）。
4. 除非已存储的响应被成功验证（4.3节），否则请求中不能包含 no-cache 参数（5.4节）或 no-cache 缓存指令（5.2.1节）。
5. 除非响应被成功校验（4.3节），否则已存储响应不包含no-cache缓存指令（5.2.2.2节）。
6. 已存储的响应的特性：
    - 是新鲜的（4.2节）
    - 允许被在过期的时候使用（4.2.4节）
    - 成功的验证（4.3节）。

注意，上面列出的任何条件都可以通过 Cache-Control 来配置，具体查看5.2.3节。

当缓存的响应不经验证就被使用时，缓存**必须**生成一个 Age 头字段（5.1节），它表示已存储响应已存在的时间，查看4.2.3节。

缓存**必须**直写请求中对原始服务器不安全的方法。RFC7231，4.2.1节），即一个缓存是不允许在转发并接收到对应的响应之前对一个请求生成响应的。

另外，不安全的请求可能会使已存储的响应无效，查看4.4节。

当匹配了多个已缓存响应的时候，缓存必须使用最近的响应（如由Date头字段确定）。它也使用发送携带有 “Cache-Control: max-age=0” 或者 “Cache-Control: no-cache” 的请求以消除使用哪个响应的歧意。

如果当前缓存没有一个可靠的时钟，在每次使用缓存的时候不得在没有经过验证的情况下使用已存储的响应。

## 4.1 用 Vary 计算辅助键

当一个缓存接收到一个可以用带有Vary头字段响应去满足的请求时（RFC7231，7.1.4节），除非Vary头字段提及的所有字段都匹配原始请求，否则它**不能**使用该响应，

当且仅当使用以下处理方式可以将第一个请求转换成第二请求时，这两个请求的选择头字段才被是认为匹配：

1. 添加或消除在头字段的语法中允许的空白。
2. 将多个有相同字段名的头字段进行组合（查看RFC7230，3.2节）。
3. 根据头字段的规范，标准化头字段（如：当顺序不重要的时候，重新排列字段的值；不区分大小写）。

如果标准化之后一个头字段从请求中缺失，这个头字段在另一个请求中也需要缺失才算匹配。

一个字段值为 “*” 的 Vary 头字段总是无法匹配。

匹配了选择头字段的响应被当作是已匹配的响应。

如果存在多个可选择的响应（可能不包含 Vary 头字段）时，缓存需要选择一个来使用。如果头字段本身拥有一个可以判断优先级的机制的话（例如：Accept以及类似的头字段），那个缓存则会通过该机制来判断哪个更优。如果没有该机制的话，最新的响应（由Date头字段确定）将被使用，如第4节。

如果没有可用的响应，缓存就不能满足当前的请求。一般情况下它将转发当前请求到源服务器。