# 1. 介绍

在分布式系统中，通常都会缓存响应数据来提升性能。该文档定义了 `HTTP / 1.1` 中缓存和重用相关响应数据的各个方面。

HTTP 缓存是一个存储了响应数据的本地仓库，该仓库同时也提供了对数据进行存储、检索（读取）、删除等操作。当我们缓存了可被缓存的响应数据时，可以减少将来相同请求的响应时间和网络带宽消耗。任何客户端、服务器都可以拥有自己的缓存，但对于扮演一个 tunnel 角色的服务器来说，不能使用缓存。

共享缓存是一个可以被多个用户使用的 Cache。通常会被部署在访问链路中的某一个节点，充当中介的身份。相反的，私有缓存的响应数据只能被单个用户使用，通常它会实现在用户代理UA（User Agent）中即一个访问发出的起点。

`HTTP / 1.1` 中使用缓存目的是通过重用可以满足当前请求的历史响应数据来提高性能。如果可以在没有“验证”的情况下重用响应，则认为缓存的数据是“新鲜的“（ 相关定义在 4.2 节），所以如果一直使用“新鲜的”缓存数据，可以有效降低延时和网络开销，当缓存的响应不再“新鲜”时，如果通过验证（ 相关定义在 4.3 节）发现它仍然可以重用或者此时后端服务器已经不可用（ 相关定义在 4.2.4 节），则依旧认为缓存数据还是“新鲜的”。

## 1.1 一致性和错误处理

关于错误处理的一致性标准和注意事项被定义在 RFC7230 的 2.5 节。

## 1.2 语法表示法

### 1.2.1 Delta Seconds 规则

delta-seconds 规则指定一个非负整数的时间，其单位为秒。
```
    delta-seconds  = 1*DIGIT
```
解析 delta-seconds 并将其转为二进制形式的接收者应该限定其最大值为一个不少于31位（2^31）的非负整数。如果缓存接收了一个超出最大值的 delta-seconds，或后续计算溢出时，缓存必须将这个值视为 2147483648 (2^31) 或者它能表示的最大正整数。

注意：值 2147483648 在这里是出于历史原因，有效地代表了无限(超过68年)。如果发生溢出，可以实现一个基于字符串的计算方案，总的来说，不管发生什么，该值都不能为负数。

# 2 缓存操作概述

正确的缓存操作保留了 HTTP 传输的语义（[RFC7231]），同时消除了已经保存在缓存中的信息。虽然缓存是一个完全可选的 HTTP 特性，在没有必要要求或本地配置取消它的情况下重用是一个默认行为，所以可以认为重用被缓存的响应是众望所归的。因此，HTTP 缓存的着重点在于避免缓存不会被重用和不应该被重用的响应数据，而不是缓存所有的响应数据并且不断重用它。

每个缓存实体由一个缓存键和一个或多个使用相同键的先前请求的 HTTP 响应组成。最常见的缓存实体形式是成功请求的结果：即GET请求的200响应，它包含了请求资源的一个标识（RFC7231，4.3.1节）。当然它也可能缓存 302 重定向的响应数据、404网页丢失的响应数据、不完整返回数据（code: 206）以及对于非 GET 请求而言，如果方法定义允许被缓存并且定义了缓存键，那么它也可以被缓存。

 缓存主键由请求方法和目标URI组成。但是，由于目前常用的 HTTP 缓存通常仅支持对 GET 的响应缓存，因此许多缓存简单地拒绝掉其他方法，仅使用URI作为缓存主键。

如果一个请求目标需要进行内容协商，它的缓存条目可能会包含多个响应，每个响应通过原始请求的请求头作为一个辅助键来区分（4.1节）。

# 3 在缓存中存储响应

遵循如下条件时，缓存会存储该请求的响应：

1. 请求方法能被缓存识别且允许被缓存。
2. 响应状态码能被缓存识别。
3. “no-store” 缓存指令（查看 5.2 节）没有出现在请求或响应头字段中。
4. 使用的是共享缓存并且“private” 响应指令（查看5.2.2.6节）没有出现在响应字段。
5. 使用的是共享缓存，默认情况下 Authorization 请求头字段不出现在请求头中才可以被缓存，但是允许服务器响应数据时通过相关字段告知可被缓存（查看3.2节）。
6. 响应数据时携带如下任一字段时会被缓存：
    - 包含 Expires 头字段（查看5.3节）。
    - 包含 max-age 响应指令（查看5.2.2.8节）。
    - 包含 s-maxage 响应指令（查看5.2.2.9节）同时是共享缓存。
    - 包含 Cache-Control 缓存控制（查看5.2.3节）。
    - 被定义为可缓存的状态码（查看4.2.2节）。
    - 包含 public 响应指令（查看5.2.2.5节）。

注意，上面列出的任何条件都可以通过 Cache-Control 来配置，具体查看5.2.3节。

在上述描述所提到的内容中，如果缓存实现了针对某个请求方法或响应状态码的相关行为，那么缓存就能识别它。

注意，一般情况下，缓存不会存储一个既没有缓存校验器又没有明确过期时间的响应数据，因为这样的响应存储下来通常是没有用的。不过，缓存没有对此作出限制。

## 3.1 存储不完整的响应

如果由消息帧组成的所有字节在连接被关闭前都被接收，则响应消息被视为完整的。如果请求方法是 GET ，响应状态码是 200，并且整个响应头部分已经被接收，缓存**可以**存储一个不完整的响应消息体，在缓存条目中被记录为不完整。同样的，206 响应也可以这样子被处理。然而，当缓存不支持 Range 和 Content-Range 头字段或者缓存无法识别头字段中使用的值时，它**不能**存储不完整或部分内容的响应数据。

缓存可以通过发起范围请求并将通过存储条目组合来完成一个不完整的响应的存储，如3.3节定义。除非响应已经是完整的，或请求所指定的范围全都在不完整响应中，否则缓存**不能**使用一个不完整的响应来应答请求。缓存**必须**在使用 206 状态码情况下才能够使用不完整响应返回给客户端。

## 3.2 存储对已认证请求的响应

共享缓存**不能**使用带 Authorization 头字段(4.2节 [RFC7235])请求的响应来满足后续请求，除非
在响应中明确指定可以被缓存。

在这个规范中，下列 Cache-Control （5.2.2 节）响应指令有这样的效果：must-revalidate，public，和 s-maxage。

注意，包含 “must-revalidate” 或 “s-maxage” 响应指令的缓存响应不允许被共享缓存处理。另外带有 “max-age=0, must-revalidate” 或 “s-maxage=0” 的响应不能在未经源服务器校验通过的情况下被用于满足后续请求。

## 3.3 合并部分内容

如果连接过早关闭或者如果请求使用了一个或多个 Range （[RFC7233]），响应可能只转移一部分表示。在几次这样的转移后，缓存可能已经接收到一些相同表示的范围。缓存可以将这些范围组成成一个存储响应，然后使用哪个响应来满足后续请求，如果他们都共享相同的强校验器并且缓存符合RFC7233中4.3节的客户端要求。

当将一个或多个已存储的响应组成新响应时，缓存必须：

1. 删除响应中的任何 1xx 的警告头字段（5.5节）。
2. 保留响应中的任何 2xx 的警告头字段。
3. 除了 Content-Range 外，新的响应中提供的头字段应该覆盖已存储响应中对应头字段。

# 4 从缓存构建响应

遵循如下条件时，缓存会使用已缓存的响应：

1. 有效请求的URI（RFC7230，5.5节）和已存储响应的URI匹配。
2. 请求方法允许它使用缓存。
3. 匹配了已存储响应（如果有的话）指定的选择头字段（4.1节）。
4. 除非已存储的响应被成功验证（4.3节），否则请求中不能包含 no-cache 参数（5.4节）或 no-cache 缓存指令（5.2.1节）。
5. 除非响应被成功校验（4.3节），否则已存储响应不包含no-cache缓存指令（5.2.2.2节）。
6. 已存储的响应的特性：
    - 是新鲜的（4.2节）
    - 允许被在过期的时候使用（4.2.4节）
    - 成功的验证（4.3节）。

注意，上面列出的任何条件都可以通过 Cache-Control 来配置，具体查看5.2.3节。

当缓存的响应不经验证就被使用时，缓存**必须**生成一个 Age 头字段（5.1节），它表示已存储响应已存在的时间，查看4.2.3节。

缓存**必须**直写请求中对原始服务器不安全的方法。RFC7231，4.2.1节），即一个缓存是不允许在转发并接收到对应的响应之前对一个请求生成响应的。

另外，不安全的请求可能会使已存储的响应无效，查看4.4节。

当匹配了多个已缓存响应的时候，缓存必须使用最近的响应（如由Date头字段确定）。它也使用发送携带有 “Cache-Control: max-age=0” 或者 “Cache-Control: no-cache” 的请求以消除使用哪个响应的歧意。

如果当前缓存没有一个可靠的时钟，在每次使用缓存的时候不得在没有经过验证的情况下使用已存储的响应。

## 4.1 用 Vary 计算辅助键

当一个缓存接收到一个可以用带有Vary头字段的响应去满足的请求时（RFC7231，7.1.4节），除非Vary头字段提及的所有字段都匹配原始请求，否则它**不能**使用该响应，

当且仅当使用以下处理方式可以将第一个请求转换成第二请求时，这两个请求的选择头字段才被是认为匹配：

1. 添加或消除在头字段的语法中允许的空白。
2. 将多个有相同字段名的头字段进行组合（查看RFC7230，3.2节）。
3. 根据头字段的规范，标准化头字段（如：当顺序不重要的时候，重新排列字段的值；不区分大小写）。

如果标准化之后一个头字段从请求中缺失，这个头字段在另一个请求中也需要缺失才算匹配。

一个字段值为 “*” 的 Vary 头字段总是无法匹配。

匹配了选择头字段的响应被当作是已匹配的响应。

如果存在多个可选择的响应（可能不包含 Vary 头字段）时，缓存需要选择一个来使用。如果头字段本身拥有一个可以判断优先级的机制的话（例如：Accept以及类似的头字段），那个缓存则会通过该机制来判断哪个更优。如果没有该机制的话，最新的响应（由Date头字段确定）将被使用，如第4节。

如果没有可用的响应，缓存就不能满足当前的请求。一般情况下它将转发当前请求到源服务器。

## 4.2 新鲜度

新鲜响应是一个其存在的时间没有超过它的新鲜度生命周期的响应。反过来，过期响应则是超过了其生命周期。

一个响应的新鲜度生命周期是从它被源站生成到它过期的时间长度。一个明确的过期时间是源服务器有意让一个被存储的响应在不经进一步验证的情况下不能被继续使用的时间，当没有明确的过期时间的时候，启发式过期时间由缓存分配。

响应的寿命是从它被源站生成或成功的从源站校验以来经过的时间。

当一个响应在缓存中是“新鲜的”，它可以被用于满足后续请求而不必联系源服务器，进而提高效率。

确定新鲜度的主要机制是源服务器通过使用 Expires 头字段（5.3节）或 max-age 响应指令（5.2.2.8），来提供一个明确的未来过期时间。通常，当源服务器认为响应数据在过期时间到来之前不太可能发生改变时就会为当前响应分配一个过期时间。

如果源服务器希望强制缓存验证每一个请求，它可以分配一个已失效的过期时间来表明响应已经失效。符合规范的缓存通常会重新验证一个过期缓存后，才将其用于后续请求。

因为源服务器并不总是提供明确的过期时间，缓存也被允许使用启发式来确定具体情况下的过期时间（4.2.2节）。

计算一个缓存是否过期的方法是：
```
响应是新鲜的 = （新鲜度生命周期 > 当前寿命）
```
新鲜度生命周期定义在4.2.1节，当前寿命的定义在4.2.3节。

客户端可以在请求中发送 max-age 或 min-fresh 缓存指令，以提供对应响应的新鲜度计算方式（5.2.1节）。

当计算新鲜度时，需要避免一些在解析时间时会遇到的普遍性问题：

1. 尽管所有的日期格式都固定要区分大小写，但缓存接收者应该不区分大小写地匹配日期、星期和时区名称。
2. 如果一个缓存接收者内部实现的时间颗粒度小于 HTTP-date 的值（即更精准），接收者**必须**在内部将解析的 Expires 日期向下取接近 Http-date 颗粒度的值。
3. 缓存接收者**不能**允许本地时区影响寿命或到期时间的计算或比较。
4. 缓存接收者在计算过期时间时，应该将出了GMT或UTC以外的区域缩写视为无效。

请注意，新鲜度只适用于缓存操作，它不能用来强制用户代理UA去刷新其显示或重新加载资源。 关于缓存和历史机制的区别，请参见第6节的解释。

### 4.2.1 计算新鲜度寿命

缓存可以按照顺序尝试匹配下列选项，第一个被匹配成功的条件会被用来计算响应的新鲜度生命期（记为freshness_lifetime）：

1. 如果缓存是共享的，并且存在 s-maxage 响应指令（5.2.2.9节），使用这个值。
2. 如果 max-age 响应指令（5.2.2.8节）存在，使用这个值。
3. 如果存在 Expires 响应头字段（5.3节），使用它的值减去 Date 响应头字段的值。
4. 除此之外，如果响应中没有明确的过期时间，可以使用一个启发式的新鲜度生命期；查看4.2.2节。

请注意，这种计算不容易受到时钟偏移的影响，因为所有的信息都来自源服务器。

如果给定的指令存在一个以上的值（例如，两个 Expires 头字段，多个 Cache-Control: max-age 指令），该指令的值被认为是无效的。 我们鼓励缓存将具有无效新鲜度信息的响应视为过期的。

### 4.2.2 计算启发式新鲜度

由于源服务器并不总是提供明确的过期时间，当没有指定明确的过期时间时，缓存可以分配一个启发式的过期时间。算法逻辑是通过使用其他头字段的值（如Last-Modified时间）来估算出一个合理的过期时间。 本规范没有提供具体的算法，但对其结果进行了最坏情况的限制。

当存储的响应中存在明确的过期时间时，缓存**必须**不使用启发式方法来确定新鲜度。 由于第 3 节的要求，这也意味着，实际上启发式方法只能用于没有明确新鲜度且状态代码默认被定义为可缓存的响应（参见 [RFC7231] 的第 6.1 节），以及那些没有明确新鲜度且已被标记为明确可缓存的响应（例如，使用 "public" 响应指令）。

如果响应有一个 Last-Modified 头字段（[RFC7232]的2.2节）时，鼓励缓存使用一个启发式的过期值，这个过期值不能超过自该时间以来的某个比例。这个比例的典型设置是 10%。

当使用启发式计算新鲜度寿命时，如果缓存的当前寿命超过 24 小时，并且 113 状态码还没有出现，那么缓存应该在响应中生成一个带有 113 警告代码码的警告头字段（参见5.5.4节）。

注意：[RFC2616]第13.9节中明确禁止缓存计算带有 query 查询参数的 URI 的启发式新鲜度（即包含'?'的URI）。 在实践中，这一点还没有得到广泛的实施。 因此，如果源服务器不希望响应被缓存，鼓励它发送明确的指令（例如，Cache-Control: no-cache）。

### 4.2.3 计算年龄

Age 头字段用于传递从缓存中获取的响应消息的估计年龄。 Age 字段的值是缓存对响应被生成或被源服务器验证后的秒数的估计。 实质上，Age 值是响应在从源服务器出发的路径上的每一个缓存中驻留的时间，加上它在网络路径上传输的时间的总和。

计算年龄时使用的数据如下：

1. age_value
    - “age_value” 表示 Age 头字段的值（5.1节），其形式适合于算术运算，如果不可用则是0。
2. date_value
    - “date_value” 表示 Date 头字段的值，其形式适合算术运算。参见 [RFC7231] 的第 7.1.1.2 节了解 Date 头字段的定义和没有这个头的响应的相关要求。
3. now
    - “now” 表示“执行计算的主机的时钟的当前值”。主机应该使用 NTP([RFC5905])或一些类似的协议将其时钟同步到协调世界时间
4. request_time
    - 导致响应被缓存的请求发出时，其主机时钟的当前值。
5. response_time
    - 收到响应时主机时钟的当前值。

响应的年龄可以用两种完全独立的方法计算得到：

1. “apparent_age”：如果本地时钟是与源服务器的时钟同步的，response_time 减去 date_value可以得到。如果结果是负的，那么用0替代。
2. “corrected_age_value”：如果响应路径上的所有缓存的实现都是基于 HTTP/1.1 的 。那么缓存必须将这个值解释为相对于请求发起的时间，而不是接收响应的时间。
```
    apparent_age = max(0, response_time - date_value);

    response_delay = response_time - request_time;
    corrected_age_value = age_value + response_delay;
组合成

    corrected_initial_age = max(apparent_age, corrected_age_value);
```

除非缓存对 Age 头字段的值有信心(例如，如果存在 Via 头字段，则不会存在HTTP/1.0 跃点)。在这种情况下， corrected_age_value 可以作为 corrected_initial_age 使用。

然后，存储响应的 current_age 可以通过将被缓存的响应最后一次被源服务器验证后的时间（以秒为单位）加到 corrected_initial_age 中来计算。

```
    resident_time = now - response_time;
    current_age = corrected_initial_age + resident_time;
```
